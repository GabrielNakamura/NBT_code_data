{
  "hash": "004a9b3830401c1ab194b9bbfd4b6834",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Functions\"\nsubtitle: \"0012_Functions.qmd\"\nformat: html\neval: FALSE\ndate: 2024-07-31\n---\n\n\n# Function for beta diversity\n\n## beta_types (function_beta_types_success_fail.R)\n\nCalculation of directional beta diversity based on Baselga's beta decomposition (turnover)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Calculation of directional beta diversity based on Baselga's beta decomposition (turnover)\n#'\n#' @param presab a presence/absence matrix with species in columns and \"communities\" in rows\n#' @param names.countries a character vector with country names. Ideally the names must be equal to the ones in the rows of presab matrix\n#'\n#' @return A data frame with six columns containing turnover values for native and types \n#'     and also sucesses and fails (realizations) for types and native\n#' @export\n#'\n#' @examples\nbeta_types <- \n  function(presab, names.countries){\n    # calculating components of beta\n    \n    beta_core_all <- betapart::betapart.core(presab)\n    \n    # splitting shared and not shared components of beta\n    m_all_notshare <- \n      lapply(names.countries, function(x){\n        row_country <- grep(pattern = gsub(\"\\\\s*\\\\([^\\\\)]+\\\\)\", \"\", x), rownames(beta_core_all$not.shared))\n        column_country <- grep(pattern = gsub(\"\\\\s*\\\\([^\\\\)]+\\\\)\", \"\", x), rownames(beta_core_all$not.shared))\n        beta_core_all$not.shared[row_country, column_country]\n      })\n    m_all_share <- \n      lapply(names.countries, function(x){\n        row_country <- grep(pattern = gsub(\"\\\\s*\\\\([^\\\\)]+\\\\)\", \"\", x), rownames(beta_core_all$shared))\n        column_country <- grep(pattern = gsub(\"\\\\s*\\\\([^\\\\)]+\\\\)\", \"\", x), rownames(beta_core_all$shared))\n        beta_core_all$shared[row_country, column_country]\n      })\n    \n    # calculating native and holotype portions\n    native_all <- \n      lapply(1:length(m_all_notshare), function(x){\n        if(!is.matrix(m_all_notshare[[x]]) | length(m_all_notshare[[x]]) == 0){\n          NA\n        } else{\n          m_all_notshare[[x]][2, 1] / (m_all_share[[x]][2, 1] + m_all_notshare[[x]][2, 1])\n        }\n      }) # native - underrepresentation)\n    \n    native_success <- \n      lapply(1:length(m_all_notshare), function(x){\n        if(!is.matrix(m_all_notshare[[x]]) | length(m_all_notshare[[x]]) == 0){\n          NA\n        } else{\n          m_all_notshare[[x]][2, 1]\n        }\n      })\n    \n    native_fail <- \n      lapply(1:length(m_all_notshare), function(x){\n        if(!is.matrix(m_all_notshare[[x]]) | length(m_all_notshare[[x]]) == 0){\n          NA\n        } else{\n          (m_all_share[[x]][2, 1] + m_all_notshare[[x]][2, 1]) - (m_all_notshare[[x]][2, 1])\n        }\n      })\n    \n    type_all <- \n      lapply(1:length(m_all_notshare), function(x){\n        if(!is.matrix(m_all_notshare[[x]]) | length(m_all_notshare[[x]]) == 0){\n          NA\n        } else{\n          if(m_all_notshare[[x]][1, 2] == 0){\n            0\n          } else{\n            m_all_notshare[[x]][1, 2] / (m_all_share[[x]][2, 1] + m_all_notshare[[x]][1, 2])\n          }\n        }\n      })\n    \n    type_success <- \n      lapply(1:length(m_all_notshare), function(x){\n        if(!is.matrix(m_all_notshare[[x]]) | length(m_all_notshare[[x]]) == 0){\n          NA\n        } else{\n          if(m_all_notshare[[x]][1, 2] == 0){\n            0\n          } else{\n            m_all_notshare[[x]][1, 2] \n          }\n        }\n      })\n    \n    type_fail <- \n      lapply(1:length(m_all_notshare), function(x){\n        if(!is.matrix(m_all_notshare[[x]]) | length(m_all_notshare[[x]]) == 0){\n          NA\n        } else{\n          if(m_all_notshare[[x]][1, 2] == 0){\n            0\n          } else{\n            (m_all_share[[x]][2, 1] + m_all_notshare[[x]][1, 2]) - (m_all_notshare[[x]][1, 2])\n          }\n        }\n      })\n    \n    # joining all in a df\n    df_native_beta <- do.call(rbind, native_all)\n    df_type_beta <- do.call(rbind, type_all)\n    df_native_success <- do.call(rbind, native_success)\n    df_native_fail <- do.call(rbind, native_fail)\n    df_type_success <- do.call(rbind, type_success)\n    df_type_fail <- do.call(rbind, type_fail)\n    df_all_beta <- data.frame(countries = names.countries, \n                              native.beta = df_native_beta, \n                              type.beta = df_type_beta, \n                              native.success = df_native_success, \n                              native.fail = df_native_fail, \n                              type.success = df_type_success, \n                              type.fail = df_type_fail)\n    \n    return(df_all_beta)\n  }\n```\n:::\n\n\n# Scale function\n\n## scale_back (function_scale_back.R)\n\nAuxiliar function to scale back standardized variables\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Auxiliar function to scale back standardized variables\n#'\n#' @param data data frame. An object from ggpredict\n#' @param scaled data frame. An object from scale\n#'\n#' @return a new data frame with the variable x_original that corresponds\n#'     to the standardized variable scaled back\n#' @export\n#'\n#' @examples\nscale_back <- \n  function(data, scaled){\n    data2 <- data.frame(data)\n    res <- \n      data2 |> \n      dplyr::mutate(x_original = as.matrix(x) * attr(scaled, 'scaled:scale') + \n               attr(scaled, 'scaled:center'))\n    return(res)\n  }\n```\n:::\n",
    "supporting": [
      "0012_Functions_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}